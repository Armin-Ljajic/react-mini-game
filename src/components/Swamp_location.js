/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: bocharova (https://sketchfab.com/apsnu)
license: CC-BY-NC-4.0 (http://creativecommons.org/licenses/by-nc/4.0/)
source: https://sketchfab.com/3d-models/swamp-location-7ede00c0dfe14574bd8f06ee36020609
title: swamp location
*/

import React, { Suspense, useEffect, useMemo, useRef } from 'react'
import { Merged, Plane, Polyhedron, RoundedBox, useGLTF } from '@react-three/drei'
import { useBox, usePlane, useConvexPolyhedron, useTrimesh } from '@react-three/cannon';
import {Model} from '../components/Archer.js'
import { GrassModel } from './Grass.js';
import { BufferAttribute, Color, PlaneGeometry } from 'three';
import { Geometry } from "three-stdlib";
import { Physics, RigidBody, Debug, CuboidCollider, WorldApi, MeshCollider, useRapier } from "@react-three/rapier";
import * as THREE from 'three'
import getPixels from "get-image-pixels";
import { useTexture } from "@react-three/drei";

export function SwampModel(props) {

  const { nodes, materials } = useGLTF('/swamp_location.glb')
  // const model = useGLTF('/swamp_location.glb');

  function loadTexture(path) {
    const texture = new THREE.TextureLoader().load(path);
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.x = 10;
    texture.repeat.y = 10;
    return texture;
}




// const texture = useTexture(materials.map_1lambert4SG.map.image);
// var pixels = getPixels(materials.map_1lambert4SG.map.image);
const heights = [];
const { rapier, world } = useRapier();



const w = materials.map_1lambert4SG.map.image.width;
const h = materials.map_1lambert4SG.map.image.height;


console.log(materials.map_1lambert4SG.map)
// const geo = useMemo(() => {
//   for (var i = 0; i < w * h * 4; i += 4)
//     heights.push((pixels[i] / 255));

//   // create physics collider - should be replaced with HeightfieldCollider
//   let rigidBody = world.createRigidBody(rapier.RigidBodyDesc.fixed());
//   let colliderDesc = rapier.ColliderDesc.heightfield(
//     w - 1,
//     h - 1,
//     new Float32Array(heights),
//     { x: w , y: 1.0, z: h }
//   );
//   world.createCollider(colliderDesc, rigidBody);

//   // create mesh
//   // initially tried using displacment but shader and height field hieght values were differnt
//   // also order of heightfield and geo are slightly differnt, def a way to do this simpler
//   const geo = new PlaneGeometry(w, h, w - 1, h - 1);
//   const f = chunk(heights, w).reverse().flat();
//   const vertices = geo.attributes.position.array;
//   for (var i = 0; i < vertices.length; i++) vertices[i * 3 + 2] = f[i];
//   return geo;
// }, [materials.map_1lambert4SG.map]);

// function chunk(arr, size) {
//   return arr.reduce(
//     (acc, e, i) => (
//       i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc
//     ),
//     []
//   );
// }

const GroundFloor = () => {
  const arrayOfVerts = nodes.Object_3.geometry.attributes.position.array;
  const vertices = useMemo(() => arrayOfVerts.map(point => new THREE.Vector3(point)), [arrayOfVerts])

  return (
    <RigidBody colliders="trimesh" type="fixed">
      <mesh
      rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
      geometry={nodes.Object_3.geometry}
      >
        <meshStandardMaterial map={materials.map_1lambert4SG.map}/>
      </mesh>
    </RigidBody>
  )
}

  return (
  

      // <GroundFloor/>
      <group {...props} dispose={null}>
        <group> 
            <RigidBody colliders="trimesh" type="fixed" rotation={[-Math.PI / 2, 0, 0]}>
              <mesh geometry={nodes.Object_2.geometry} material={materials.map_1blinn6SG} name="obj1"/>
              <mesh geometry={nodes.Object_3.geometry} material={materials.map_1lambert4SG} name="obj2"/>
              <mesh geometry={nodes.Object_4.geometry} material={materials.map_1object} name="obj3"/>
              <mesh geometry={nodes.Object_5.geometry} material={materials.map_1object} name="obj4" />
              <mesh geometry={nodes.Object_6.geometry} material={materials.map_1lambert5SG} name="obj5" /> 
            </RigidBody>
        </group>
      </group>
   
  )
}

useGLTF.preload('/swamp_location.glb')

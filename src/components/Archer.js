/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useAnimations, PerspectiveCamera, OrbitControls, CycleRaycast , useHelper, PointerLockControls} from '@react-three/drei'
import * as THREE from 'three';
import {Quaternion, Raycaster, Vector3, BoxHelper} from 'three';
import { useFrame, useThree, extend } from '@react-three/fiber';
import { useInput } from '../hooks/useInput';
import { Physics, RapierCollider, RigidBody, useRapier } from '@react-three/rapier';
import { useBox, useConvexPolyhedron, useSpring } from '@react-three/cannon';
import { Geometry } from "three-stdlib";
import { lerp } from 'three/src/math/MathUtils';
import { SwampModel } from './Swamp_location';
import { Arrow } from './Arrow';
import { PlaneBufferGeometry } from 'three';
import { MeshStandardMaterial } from 'three';


const directionOffset = ({forward, backward, left, right}) => {
  var directionOffset = 0; // w

  if(forward){
    if(left){
      directionOffset = Math.PI / 4 // w+a
    } else if (right){
      directionOffset = -Math.PI / 4 // w+d
    }
  } else if(backward){
    if(left) {
      directionOffset = Math.PI / 4 + Math.PI / 2 // s+a
    } else if (right){
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if(left){
    directionOffset = Math.PI / 2; // a
  } else if(right){
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

const useForwardRaycast = (obj) => {
  const raycaster = useMemo(() => new Raycaster(), [])
  const pos = useMemo(() => new Vector3(), [])
  const dir = useMemo(() => new Vector3(), [])
  dir.set(0, -1 , 0)
  const scene = useThree((state) => state.scene)
  
  return () => {
    if (!obj.current) return []
    // raycaster.set(obj.current.getWorldPosition(pos), obj.current.getWorldDirection(dir))
    raycaster.set(obj.current.getWorldPosition(pos), dir)
    return raycaster.intersectObjects(scene.children)
  }
}

export function Model({action, position}) {

  const group = useRef()
  const currentAction = useRef("");
  const controlsRef = useRef(OrbitControls);
  const {forward, backward, left, right, jump, shift, shoot} = useInput();
  const model = useGLTF('/ErikaArcherWithAimingAnimationsNew.glb');
  const arrowModel = useGLTF("/arrow.glb")
  const { actions } = useAnimations(model.animations, model.scene)
  const { mixer } = useAnimations(model.animations)
  const previousAction = usePrevious(action);
  const camera = useThree(state => state.camera);
  const {scene} = useThree();
  const { rapier, world, rigidBody} = useRapier();
  const swampRaycaster = useMemo(() => new Raycaster(), [])
  const [arrows, setArrows] = useState([]);

  const api = useRef();
  const ref = useRef({
    timeToShoot: 0
  });
  const swampRef = useRef();
  const raycast = useForwardRaycast(ref);
  const swampRaycast = useForwardRaycast(swampRef);
  const arrowRef = useRef();

  const arrowSpeed = 80;
  const arrowCoolDown = 300;
  let timeToShoot = 0;

  const state = useRef({
    timeToShoot: 0,
    timeTojump: 0,
    vel: [0, 0, 0],
    jumping: false
  });

  const updateCameraTarget = (moveX, moveZ) => {
    // move camera
    camera.position.x += moveX;
    camera.position.z += moveZ;
    // camera.position.y += moveY;
    

    // update camera target
    cameraTarget.x = model.scene.position.x;
    cameraTarget.y = model.scene.position.y + 2;
    cameraTarget.z = model.scene.position.z;
    if(controlsRef.current) controlsRef.current.target = cameraTarget;
  };


  let walkDirection = new THREE.Vector3();
  let rotateAngle = new THREE.Vector3(0, 1, 0);
  let rotateQuarternion = new THREE.Quaternion();
  let cameraTarget = new THREE.Vector3();
  const speed = new THREE.Vector3();
  const SPEED = 5;
  const SwampModelRef = useRef();
  const down = new THREE.Vector3(0, -1, 0);
  const raycaster = new THREE.Raycaster();
  let storedFall = 0;
  

  
  useEffect(() => {

   
    
    if(previousAction){
      // actions[previousAction].stop()
    }
    let action = "";
    const now = Date.now();
    
    if(forward|| backward || left || right){
      action = "WalkForward";
      if(shift){
        action = "RunForward"
        if(jump){
          action = "RunningJump"
        }
      }
    } else if(jump){
      action = "Jump";

    } else if(shoot){
      action = "StandingDrawArrow";
      console.log(actions[action]._mixer._actions[12])
      actions[action].crossFadeTo(actions[action]._mixer._actions[12], 0.5, false);
      // actions[action]?.setLoop(THREE.LoopOnce)

    } else{
      action = "Idle";

    } 

    if(currentAction.current != action){
      const nextActionToPlay = actions[action];
      const current = actions[currentAction.current];
      current?.fadeOut(0.2);
      nextActionToPlay?.reset().fadeIn().play();
      currentAction.current = action;
    }

    
    // actions[action].play();
    // nodes.Armature.position.x;

    }, [action, actions, forward, backward, left, right, jump, shift, shoot]);


    useFrame((state, delta) => {
      if(currentAction.current === "WalkForward" ||
      currentAction.current === "RunForward"
      ) {
        //calculate towards camera direction
        let angleYCameraDirection = Math.atan2(
          camera.position.x - model.scene.position.x,
          camera.position.z - model.scene.position.z
        )
        // console.log(actions)

        //diagonal movement angle offset
        let newDirectionOffset = directionOffset({
          forward,
          backward,
          left,
          right,
        });

        rotateQuarternion.setFromAxisAngle(
          rotateAngle,
          angleYCameraDirection + newDirectionOffset
        )
        model.scene.quaternion.rotateTowards(rotateQuarternion, 0.2);
        

        // calculate direction
        camera.getWorldDirection(walkDirection);
        walkDirection.y = 0;
        walkDirection.normalize();
        walkDirection.applyAxisAngle(rotateAngle, newDirectionOffset)

        // run/walk velocity
        let velocity = currentAction.current == "RunForward" ? 4 : 1.8;


        //intersections
        const intersections = raycast();
        const swampIntersections = swampRaycast();
        
        const walkable = scene.children.filter(
          (o) => o.children[0]?.uuid !== ref?.current?.uuid
        );
  
      const translation = api.current.translation();
      if (translation.y < -1) {
        // don't fall below ground
            // model.scene.position.x = 0;
            // model.scene.position.y = 10; 
            // model.scene.position.z =  0;
            translation.x = 0;
            translation.y = 10; 
            translation.z =  0;
        }
    
      // } else {
        walkDirection.y += (storedFall, -9.81 * delta, 0.10)
        storedFall = walkDirection.y
        
        if(intersections.length > 0){
          model.scene.position.copy(intersections[0].point)
          const point = intersections[0].point;
          let diff = model.scene.position.y - (point.y + 0.28);
          if(diff < 0.0){
            storedFall = 0;
            walkDirection.y += lerp(0, Math.abs(diff), 0.5);
            // console.log(point);
          }
        }

        // update model and camera
        const moveX = walkDirection.x * velocity * delta;
        const moveZ = walkDirection.z * velocity * delta;
        
        
        translation.x = model.scene.position.x += moveX;
        translation.y = model.scene.position.y += walkDirection.y
        translation.z = model.scene.position.z += moveZ;

        updateCameraTarget(moveX, moveZ);

       
        
      };

      

      let cameraDirection = new Vector3();
      camera.getWorldDirection(cameraDirection);

      //Shooting
      const arrowDirectionX = cameraDirection.x * arrowSpeed * delta;
      const arrowDirectionY = cameraDirection.y * arrowSpeed * delta;
      const arrowDirectionZ = cameraDirection.z * arrowSpeed * delta;

      arrowModel.scene.position.x += arrowDirectionX
      arrowModel.scene.position.y += arrowDirectionY
      arrowModel.scene.position.z += arrowDirectionZ

      const arrowPosition = model.scene.position.clone()
      .add(cameraDirection.clone().multiplyScalar(2))

      if(currentAction.current === "StandingDrawArrow") {
        const now = Date.now();
        if (now >= timeToShoot) {
          timeToShoot = now + arrowCoolDown;
          setArrows((arrows) => [
            ...arrows,
            {
              id: now,
              position: [arrowPosition.x, arrowPosition.y+1.5, arrowPosition.z],
              rotation: [cameraDirection.x+5, cameraDirection.y+5, cameraDirection.z+5]
              // forward: [arrowModel.scene.position.x += arrowDirectionX, arrowModel.scene.position.y += arrowDirectionY, arrowModel.scene.position.z += arrowDirectionZ]
            }
          ]);
        }
      }
    });

    // function ShootController() {
    //   return (
    //     <mesh position={[0, 0, -8]}
    //     onClick={() => setArrows([
    //       ...arrows,
    //       {
    //         id: Math.random(), // This needs to be unique.. Random isn't perfect but it works. Could use a uuid here.
    //         x: 0,
    //         y: 0,
    //         z: 0,
    //         velocity: [model.scene.rotation.x * 6, model.scene.rotation.y * 5, model.scene.rotation.z * 5]
    //       }
    //     ])}>
    //       <planeGeometry attach="geometry" args={[100, 100]} />
    //         <meshStandardMaterial
    //           attach="material"
    //           color="orange"
    //           emissive="#ff0860"
    //           visible={true}
    //         />
    //     </mesh>
    //   )
    // }

    // function Arrows(){
    //   return (
    //     <group>
    //         {arrows.map((arrow) => {
    //           return (
    //             <RigidBody type="dynamic" colliders="cuboid" ref={arrowRef} >
    //                 <Arrow 
    //                   rotation={[0, 5 ,0]} 
    //                   position={arrow.position} 
    //                   velocity={arrow.forward}
    //                   key={`${arrow.id}`}
    //                 />
    //             </RigidBody>
    //           );
    //       })}
    //   </group>
    //   )
      
    // }

    return (
    <>
          
          <OrbitControls ref={controlsRef} target={model.scene.position}/>
          <group>
            <RigidBody ref={api} colliders="ball" type="kinematicPosition" >
              <primitive object={model.scene} ref={ref} name="Archer" key={model.scene.uuid} position={[-0.2, 3.1, 32]}/> 
            </RigidBody>
            {/* <RigidBody type="fixed" colliders="trimesh" rotation={[-Math.PI / 2, 0, 0]}>
              <primitive object={swampModel.scene} ref={SwampModelRef} />
            </RigidBody> */}
            {/* <RigidBody colliders="trimesh" type="fixed" rotation={[-Math.PI / 2, 0, 0]}>
              <mesh geometry={nodes.Object_2.geometry} material={materials.map_1blinn6SG}/>
              <mesh geometry={nodes.Object_3.geometry} material={materials.map_1lambert4SG} ref={swampRef} name="MapGround"/>
              <mesh geometry={nodes.Object_4.geometry} material={materials.map_1object}/>
              <mesh geometry={nodes.Object_5.geometry} material={materials.map_1object}  name="MapGeometry"/>
              <mesh geometry={nodes.Object_6.geometry} material={materials.map_1lambert5SG}/> 
            </RigidBody> */}
            {/* <ShootController/> */}
            {/* <Arrows/> */}
          
          </group>
            
          {arrows.map((arrow) => {
              return (
                <RigidBody type="kinematicPosition" colliders="trimesh" >
                  {/* <Arrow 
                    rotation={[0, 5 ,0]} 
                    position={arrow.position} 
                    // velocity={arrow.forward}
                    key={`${arrow.id}`}
                  /> */}
                  <primitive 
                  visible={!shoot}
                  object={arrowModel.scene} 
                  ref={arrowRef} 
                  position={arrow.position} 
                  key={`${arrow.id}`} 
                  scale={0.010}
                  rotation={arrow.rotation}
                  />
                </RigidBody>
              );
          })}
          {/* {arrows.map(({key, ...props}) => {
            <RigidBody>
              <Arrow key={key} {...props}/>
            </RigidBody>
          })} */}

            
            


  {/* <OrbitControls ref={controlsRef}/>
    <group ref={group} dispose={null}>
         <group name="Scene">
           <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <primitive object={model.nodes.mixamorigHips} />
            <skinnedMesh name="Erika_Archer_Arrow_Mesh"
            geometry={model.nodes.Erika_Archer_Arrow_Mesh.geometry}
            material={model.materials.Akai_MAT1}
            skeleton={model.nodes.Erika_Archer_Arrow_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Body_Mesh"
            geometry={model.nodes.Erika_Archer_Body_Mesh.geometry}
            material={model.materials.Bow_MAT}
            skeleton={model.nodes.Erika_Archer_Body_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Bow_Mesh"
            geometry={model.nodes.Erika_Archer_Bow_Mesh.geometry}
            material={model.materials.EyeSpec_MAT1}
            skeleton={model.nodes.Erika_Archer_Bow_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Clothes_Mesh"
            geometry={model.nodes.Erika_Archer_Clothes_Mesh.geometry}
            material={model.materials.phong1}
            skeleton={model.nodes.Erika_Archer_Clothes_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Eyelashes_Mesh"
            geometry={model.nodes.Erika_Archer_Eyelashes_Mesh.geometry}
            material={model.materials.Body_MAT1}
            skeleton={model.nodes.Erika_Archer_Eyelashes_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Eyes_Mesh"
            geometry={model.nodes.Erika_Archer_Eyes_Mesh.geometry}
            material={model.materials.Arrow_MAT}
            skeleton={model.nodes.Erika_Archer_Eyes_Mesh.skeleton}
            />
          </group>
        </group>
    </group> */}




    </>


    // <group ref={group} dispose={null}>
    //     <group name="Scene">
    //       <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
    //         <primitive object={nodes.mixamorigHips} />
    //         <skinnedMesh name="Erika_Archer_Arrow_Mesh"
    //         geometry={nodes.Erika_Archer_Arrow_Mesh.geometry}
    //         material={materials.Akai_MAT1}
    //         skeleton={nodes.Erika_Archer_Arrow_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Body_Mesh"
    //         geometry={nodes.Erika_Archer_Body_Mesh.geometry}
    //         material={materials.Bow_MAT}
    //         skeleton={nodes.Erika_Archer_Body_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Bow_Mesh"
    //         geometry={nodes.Erika_Archer_Bow_Mesh.geometry}
    //         material={materials.EyeSpec_MAT1}
    //         skeleton={nodes.Erika_Archer_Bow_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Clothes_Mesh"
    //         geometry={nodes.Erika_Archer_Clothes_Mesh.geometry}
    //         material={materials.phong1}
    //         skeleton={nodes.Erika_Archer_Clothes_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Eyelashes_Mesh"
    //         geometry={nodes.Erika_Archer_Eyelashes_Mesh.geometry}
    //         material={materials.Body_MAT1}
    //         skeleton={nodes.Erika_Archer_Eyelashes_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Eyes_Mesh"
    //         geometry={nodes.Erika_Archer_Eyes_Mesh.geometry}
    //         material={materials.Arrow_MAT}
    //         skeleton={nodes.Erika_Archer_Eyes_Mesh.skeleton}
    //         />
    //       </group>
    //     </group>
    // </group>
  )
}

useGLTF.preload('/archer.glb')

function usePrevious(value){
  const ref = useRef();
  useEffect(() => {
    ref.current = value
  },[value]);
  return ref.current;
}
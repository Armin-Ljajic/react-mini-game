/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useAnimations, PerspectiveCamera, OrbitControls, CycleRaycast , useHelper} from '@react-three/drei'
import * as THREE from 'three';
import {Quaternion, Raycaster, Vector3, BoxHelper} from 'three';
import { useFrame, useThree } from '@react-three/fiber';
import { useInput } from '../hooks/useInput';
import { Physics, RapierCollider, RigidBody, useRapier } from '@react-three/rapier';
import { useBox, useConvexPolyhedron } from '@react-three/cannon';
import { Geometry } from "three-stdlib";
import { lerp } from 'three/src/math/MathUtils';
import { SwampModel } from './Swamp_location';


const directionOffset = ({forward, backward, left, right}) => {
  var directionOffset = 0; // w

  if(forward){
    if(left){
      directionOffset = Math.PI / 4 // w+a
    } else if (right){
      directionOffset = -Math.PI / 4 // w+d
    }
  } else if(backward){
    if(left) {
      directionOffset = Math.PI / 4 + Math.PI / 2 // s+a
    } else if (right){
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if(left){
    directionOffset = Math.PI / 2; // a
  } else if(right){
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

const useForwardRaycast = (obj) => {
  const raycaster = useMemo(() => new Raycaster(), [])
  const pos = useMemo(() => new Vector3(), [])
  const dir = useMemo(() => new Vector3(), [])
  const scene = useThree((state) => state.scene)
  
  return () => {
    if (!obj.current) return []
    raycaster.set(obj.current.getWorldPosition(pos), obj.current.getWorldDirection(dir))
    return raycaster.intersectObjects(scene.children)
  }
}

export function Model({action, position}) {

  const group = useRef()
  const currentAction = useRef("");
  const controlsRef = useRef(OrbitControls);
  const {forward, backward, left, right, jump, shift} = useInput();
  const model = useGLTF('/ErikaArcherWithAnimationsRotated.glb');
  const { actions } = useAnimations(model.animations, model.scene)
  const previousAction = usePrevious(action);
  const camera = useThree(state => state.camera);
  const {scene} = useThree();
  const { rapier, world } = useRapier();

  const api = useRef(null);
  const ref = useRef();
  const swampRef = useRef();
  const raycast = useForwardRaycast(ref);
  const swampRaycast = useForwardRaycast(swampRef);

  

  const updateCameraTarget = (moveX, moveZ) => {
    // move camera
    camera.position.x += moveX;
    camera.position.z += moveZ;
    // camera.position.y += moveY;
    

    // update camera target
    cameraTarget.x = model.scene.position.x;
    cameraTarget.y = model.scene.position.y + 2;
    cameraTarget.z = model.scene.position.z;
    if(controlsRef.current) controlsRef.current.target = cameraTarget;
  };


  let walkDirection = new THREE.Vector3();
  let rotateAngle = new THREE.Vector3(0, 1, 0);
  let rotateQuarternion = new THREE.Quaternion();
  let cameraTarget = new THREE.Vector3();
  const speed = new THREE.Vector3();
  const SPEED = 5;
  const SwampModelRef = useRef();
  const down = new THREE.Vector3(0, -1, 0);
  const raycaster = new THREE.Raycaster();
  let storedFall = 0;
  var boundingBoxHelperObject = new THREE.BoxHelper()
  const velocity = useRef([0, 0, 0]);
  useEffect(() => {
    
    // console.log(actions)
    if(previousAction){
      // actions[previousAction].stop()
    }
    let action = "";

    if(forward|| backward || left || right){
      action = "WalkForward";
      if(shift){
        action = "RunForward"
        if(jump){
          action = "RunningJump"
        }
      }
    } else if(jump){
      action = "Jump";
    } else{
      action = "Idle";
    }

    if(currentAction.current != action){
      const nextActionToPlay = actions[action];
      const current = actions[currentAction.current];
      current?.fadeOut(0.2);
      nextActionToPlay?.reset().fadeIn().play();
      currentAction.current = action;
    }

    // actions[action].play();
    // nodes.Armature.position.x;

    }, [action, actions, forward, backward, left, right, jump, shift]);


    useFrame((state, delta) => {
      if(currentAction.current === "WalkForward" ||
      currentAction.current === "RunForward"
      ) {
        //calculate towards camera direction
        let angleYCameraDirection = Math.atan2(
          camera.position.x - model.scene.position.x,
          camera.position.z - model.scene.position.z
        )

        //diagonal movement angle offset
        let newDirectionOffset = directionOffset({
          forward,
          backward,
          left,
          right,
        });

        rotateQuarternion.setFromAxisAngle(
          rotateAngle,
          angleYCameraDirection + newDirectionOffset
        )
        model.scene.quaternion.rotateTowards(rotateQuarternion, 0.2);

        
        
        // calculate direction
        camera.getWorldDirection(walkDirection);
        walkDirection.y = 0;
        walkDirection.normalize();
        walkDirection.applyAxisAngle(rotateAngle, newDirectionOffset)

        // run/walk velocity
        let velocity = currentAction.current == "RunForward" ? 4 : 1.8;
          //intersections
          
        const intersections = raycast();
        const swampIntersections = swampRaycast();
        // const intersections = raycaster.intersectObjects(swampModel, false)
        // var intersects = raycaster.intersectObjects(model, true);
        
        

        // arrowHelper.setDirection(n)
        // if (intersections[0].point.y < -1) {
        //     // don't fall below ground
        //     model.scene.position.y = 10;
        //     model.scene.position.x = 0;
        //     model.scene.position.z = 0;
           
        // } 
        const walkable = scene.children.filter(
          (o) => o.children[0]?.uuid !== ref?.current?.uuid
        );
        // console.log(walkable)
        
        // update model and camera
        const moveX = walkDirection.x * velocity * delta;
        const moveZ = walkDirection.z * velocity * delta;
        const moveY = walkDirection.y * velocity * delta;
        // if(intersections.some(x => x.object.name === "MapGeometry")){
        //   velocity = 0;
        //   model.scene.position.x += 0.025;
        //   model.scene.position.z += 0.025;
        // }
        
        // let moveY = walkDirection.y * velocity * delta;
        intersections[0].point.x = model.scene.position.x += moveX;
        intersections[0].point.y = model.scene.position.y += moveY;
        intersections[0].point.z = model.scene.position.z += moveZ;
        
        // intersections[0].point.y = model.scene.position.y += moveY;
            
            updateCameraTarget(moveX, moveZ);

            // console.log(intersections.filter(x => x.object.name === "MapGeometry")[0].point)
            // console.log(swampRef.current.uuid)
          
            // moveY += lerp(storedFall, -9.81 * delta, 0.10)
            // storedFall = moveY
          
            // if (intersections.length > 0) {
            //     // const point = this.ray.pointAt(hit.toi);
            //     const point = intersections[0].point
            //     let diff = model.scene.position.y - ( point.y + 0.28);
            //     if (diff < 0.0) {
            //         storedFall = 0
            //         moveY = lerp(0, Math.abs(diff), 0.5)
            //     }
            // }
          console.log(intersections.filter(x => x.object.name === "MapGround").map(x => x.point))
        
        

        // move model & camera
        // const moveX = walkDirection.x * velocity * delta;
        // const moveZ = walkDirection.z * velocity * delta;
        // intersections[0].point.x = model.scene.position.x += moveX
        // intersections[0].point.z = model.scene.position.z += moveZ
        // updateCameraTarget(moveX, moveZ);



          // walkDirection.y += lerp(storedFall, -9.81 * delta, 0.10)
          // storedFall = walkDirection.y;
  
          // if(intersections.length > 0){
          //   const point = intersections[0].point;
          //   let diff = model.scene.position.y  - ( point.y + 0.28);
          //   if (diff < 0.0) {
          //       storedFall = 0
          //       walkDirection.y = lerp(0, Math.abs(diff), 0.5)
          //   }
          // }
          // const moveX = walkDirection.x * velocity * delta;
          // let moveY = walkDirection.y * velocity * delta;
          // const moveZ = walkDirection.z * velocity * delta;
  
          // intersections[0].point.x = model.scene.position.x += moveX
          // intersections[0].point.y = model.scene.position.y += moveY;  
          // intersections[0].point.z = model.scene.position.z += moveZ
          // raycaster.set(model.scene.position, down);
          // const ground = raycaster.intersectObjects(walkable)[0];
          // if (intersections.length > 0)
          if(intersections.length > 0){
            const n = new THREE.Vector3()
            // n.transformDirection(intersections[0].object.matrixWorld)
            
              model.scene.position.copy(intersections[0].point) 
              // model.scene.position.copy(intersections.filter(x => x.object.name === "MapGround").map(x => x.point))
          }
        
      };
      
    });
    
    const { nodes, materials } = useGLTF('/swamp_location.glb')
    const swampModel = useGLTF('/swamp_location.glb');

    return (
    <>

          <OrbitControls ref={controlsRef} target={model.scene.position}/>
          <group>
            <RigidBody colliders="ball" type="kinematicPosition" onCollisionEnter={({ manifold, target, other }) => {
                    // console.log(
                    //   "Collision at world position ",
                    //   manifold.solverContactPoint(0)
                    // )
                    if (other.rigidBodyObject) {
                      console.log(
                        // this rigid body's Object3Da
                        target.rigidBodyObject,
                        " collided with ",
                        // the other rigid body's Object3D
                        other.rigidBodyObject,
                      );
                    }

                    }}>
              <primitive object={model.scene} ref={ref} name="Archer" position={[-0.2, 3.1, 32]}/>
            </RigidBody>
            {/* <RigidBody type="fixed" colliders="trimesh">
              <primitive object={swampModel.scene} ref={SwampModelRef}/>
            </RigidBody> */}
            <RigidBody colliders="trimesh" type="fixed" rotation={[-Math.PI / 2, 0, 0]}>
              <mesh geometry={nodes.Object_2.geometry} material={materials.map_1blinn6SG}/>
              <mesh geometry={nodes.Object_3.geometry} material={materials.map_1lambert4SG} name="MapGround"/>
              <mesh geometry={nodes.Object_4.geometry} material={materials.map_1object}/>
              <mesh geometry={nodes.Object_5.geometry} material={materials.map_1object} ref={swampRef} name="MapGeometry"/>
              <mesh geometry={nodes.Object_6.geometry} material={materials.map_1lambert5SG}  /> 
            </RigidBody>
          </group>

            
            


  {/* <OrbitControls ref={controlsRef}/>
    <group ref={group} dispose={null}>
         <group name="Scene">
           <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <primitive object={model.nodes.mixamorigHips} />
            <skinnedMesh name="Erika_Archer_Arrow_Mesh"
            geometry={model.nodes.Erika_Archer_Arrow_Mesh.geometry}
            material={model.materials.Akai_MAT1}
            skeleton={model.nodes.Erika_Archer_Arrow_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Body_Mesh"
            geometry={model.nodes.Erika_Archer_Body_Mesh.geometry}
            material={model.materials.Bow_MAT}
            skeleton={model.nodes.Erika_Archer_Body_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Bow_Mesh"
            geometry={model.nodes.Erika_Archer_Bow_Mesh.geometry}
            material={model.materials.EyeSpec_MAT1}
            skeleton={model.nodes.Erika_Archer_Bow_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Clothes_Mesh"
            geometry={model.nodes.Erika_Archer_Clothes_Mesh.geometry}
            material={model.materials.phong1}
            skeleton={model.nodes.Erika_Archer_Clothes_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Eyelashes_Mesh"
            geometry={model.nodes.Erika_Archer_Eyelashes_Mesh.geometry}
            material={model.materials.Body_MAT1}
            skeleton={model.nodes.Erika_Archer_Eyelashes_Mesh.skeleton}
            />
            <skinnedMesh name="Erika_Archer_Eyes_Mesh"
            geometry={model.nodes.Erika_Archer_Eyes_Mesh.geometry}
            material={model.materials.Arrow_MAT}
            skeleton={model.nodes.Erika_Archer_Eyes_Mesh.skeleton}
            />
          </group>
        </group>
    </group> */}




    </>


    // <group ref={group} dispose={null}>
    //     <group name="Scene">
    //       <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
    //         <primitive object={nodes.mixamorigHips} />
    //         <skinnedMesh name="Erika_Archer_Arrow_Mesh"
    //         geometry={nodes.Erika_Archer_Arrow_Mesh.geometry}
    //         material={materials.Akai_MAT1}
    //         skeleton={nodes.Erika_Archer_Arrow_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Body_Mesh"
    //         geometry={nodes.Erika_Archer_Body_Mesh.geometry}
    //         material={materials.Bow_MAT}
    //         skeleton={nodes.Erika_Archer_Body_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Bow_Mesh"
    //         geometry={nodes.Erika_Archer_Bow_Mesh.geometry}
    //         material={materials.EyeSpec_MAT1}
    //         skeleton={nodes.Erika_Archer_Bow_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Clothes_Mesh"
    //         geometry={nodes.Erika_Archer_Clothes_Mesh.geometry}
    //         material={materials.phong1}
    //         skeleton={nodes.Erika_Archer_Clothes_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Eyelashes_Mesh"
    //         geometry={nodes.Erika_Archer_Eyelashes_Mesh.geometry}
    //         material={materials.Body_MAT1}
    //         skeleton={nodes.Erika_Archer_Eyelashes_Mesh.skeleton}
    //         />
    //         <skinnedMesh name="Erika_Archer_Eyes_Mesh"
    //         geometry={nodes.Erika_Archer_Eyes_Mesh.geometry}
    //         material={materials.Arrow_MAT}
    //         skeleton={nodes.Erika_Archer_Eyes_Mesh.skeleton}
    //         />
    //       </group>
    //     </group>
    // </group>
  )
}

useGLTF.preload('/archer.glb')

function usePrevious(value){
  const ref = useRef();
  useEffect(() => {
    ref.current = value
  },[value]);
  return ref.current;
}
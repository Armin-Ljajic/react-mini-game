/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useAnimations, PerspectiveCamera, OrbitControls, CycleRaycast , useHelper, PointerLockControls, Trail, Sphere} from '@react-three/drei'
import * as THREE from 'three';
import {Quaternion, Raycaster, Vector3, BoxHelper} from 'three';
import { useFrame, useThree, extend } from '@react-three/fiber';
import { useInput } from '../hooks/useInput';
import { Physics, RapierCollider, RigidBody, useRapier } from '@react-three/rapier';
import { lerp } from 'three/src/math/MathUtils';
import {Target} from './Target';
import { archerPositionState, targetPositionState, crosshairPositionState} from "../state/GameState";
import { useRecoilState, useRecoilValue } from 'recoil';
import { useSpring, animated } from '@react-spring/three'
import Crosshair from './Crosshair';



const directionOffset = ({forward, backward, left, right}) => {
  var directionOffset = 0; // w

  if(forward){
    if(left){
      directionOffset = Math.PI / 4 // w+a
    } else if (right){
      directionOffset = -Math.PI / 4 // w+d
    }
  } else if(backward){
    if(left) {
      directionOffset = Math.PI / 4 + Math.PI / 2 // s+a
    } else if (right){
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if(left){
    directionOffset = Math.PI / 2; // a
  } else if(right){
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

const useForwardRaycast = (obj) => {
  const raycaster = useMemo(() => new Raycaster(), [])
  const pos = useMemo(() => new Vector3(), [])
  const dir = useMemo(() => new Vector3(), [])
  dir.set(0, -1 , 0)
  const scene = useThree((state) => state.scene)
  
  return () => {
    if (!obj.current) return []
    // raycaster.set(obj.current.getWorldPosition(pos), obj.current.getWorldDirection(dir))
    raycaster.set(obj.current.getWorldPosition(pos), dir)
    return raycaster.intersectObjects(scene.children)
  }
}

const useForwardRaycastArrow = (obj) => {
  const raycaster = useMemo(() => new Raycaster(), [])
  const pos = useMemo(() => new Vector3(), [])
  const dir = useMemo(() => new Vector3(), [])
  const scene = useThree((state) => state.scene)
  
  return () => {
    if (!obj.current) return []
    raycaster.set(obj.current.getWorldPosition(pos), obj.current.getWorldDirection(dir))
    // raycaster.set(obj.current.getWorldPosition(pos), dir)
    return raycaster.intersectObjects(scene.children, true)
  }
}




export function Model({action}) {
  // const {pos} = Target();

  const group = useRef()
  const currentAction = useRef("");
  const controlsRef = useRef(OrbitControls);
  let {forward, backward, left, right, jump, shift, shoot} = useInput();
  const model = useGLTF('/ErikaArcherWithAimingAnimationsNew.glb');
  const arrowModel = useGLTF("/arrow.glb")
  const { actions } = useAnimations(model.animations, model.scene)
  const previousAction = usePrevious(action);
  // const camera = useThree(state => state.camera);
  const {camera} = useThree();
  const {scene} = useThree();
  const [arrows, setArrows] = useState([{id: 0, position: [0, 0, 0], forward: [0, 0, 0]}]);
  const crosshairPos = useRecoilValue(crosshairPositionState);
  const [arrowVisibility, setArrowVisibility] = useState(false);
  const [release, setRelease] = useState(false);

  const { rapier, world } = useRapier();
  const rapierWorld = world.raw();


  const api = useRef();
  const arrowApi = useRef();
  const ref = useRef();
  const swampRef = useRef();
  const arrowRef = useRef();
  const raycast = useForwardRaycast(ref);
  const arrowRaycast = useForwardRaycastArrow(arrowRef);
  const raycaster = new THREE.Raycaster();
  

  


  const arrowSpeed = 100;
  const arrowCoolDown = 300;
  let timeToShoot = 0;

 

  const updateCameraTarget = (moveX, moveZ) => {
    // move camera
    camera.position.x += moveX;
    camera.position.z += moveZ;
    // camera.position.y += moveY;
    

    // update camera target
    cameraTarget.x = model.scene.position.x;
    cameraTarget.y = model.scene.position.y + 2;
    cameraTarget.z = model.scene.position.z;
    if(controlsRef.current) controlsRef.current.target = cameraTarget;
  };


  let walkDirection = new THREE.Vector3();
  let rotateAngle = new THREE.Vector3(0, 1, 0);
  let rotateQuarternion = new THREE.Quaternion();
  let cameraTarget = new THREE.Vector3();
  let storedFall = 0;
  const pos2 =  new Vector3()
  const dir2 =  new Vector3()
  const arrowRaycaster = new THREE.Raycaster();

 
const setArrowRelease = (e) => {
  if(e){
    const nextActionToPlay = actions["StandingDrawArrowRelease"]
    const current = actions[currentAction.current];
    current?.fadeOut(0.2);
    nextActionToPlay?.reset().fadeIn().play();
    currentAction.current = action;
    actions[action].clampWhenFinished = true;
    actions[action].setLoop(THREE.LoopOnce, 1);
    actions[action].timeScale = 1;
    
  }
 
} 


  useEffect(() => {
    cameraTarget.x = model.scene.position.x;
    cameraTarget.y = model.scene.position.y + 2;
    cameraTarget.z = model.scene.position.z;
    if(controlsRef.current) controlsRef.current.target = cameraTarget;


    // if(arrowRef.current == undefined){
    //   setArrows((arrows) => [
    //     ...arrows,
    //     {
    //       id: 0,
    //       position: [0, 0, 0],
    //     }
    //   ]);
    // }
    // console.log(arrows)
    if(previousAction){
      // actions[previousAction].stop()
    }

   
    

    
    if(forward|| backward || left || right){
      action = "WalkForward";
      if(shift){
        action = "RunForward"
        if(jump){
          action = "RunningJump"
        }
      }
    } else if(jump){
      action = "Jump";

    } else if(shoot){
      action = "StandingDrawArrow";
      actions[action].clampWhenFinished = true;
      actions[action].setLoop(THREE.LoopOnce, 1);
      actions[action].timeScale = 1;
      setRelease(true);
      // actions[action]._mixer.addEventListener('finished', setArrowRelease)

    } else if(shoot == false && release == true){
      action = "StandingDrawArrowRelease";
      actions[action].clampWhenFinished = true;
      actions[action].setLoop(THREE.LoopOnce, 1);
      actions[action].timeScale = 1;
      setRelease(!release)

    } else{
      action = "Idle";
      
    } 
    
    
    if(currentAction.current !== action){
      const nextActionToPlay = actions[action];
      const current = actions[currentAction.current];
      current?.fadeOut(0.2);
      nextActionToPlay?.reset().fadeIn().play();
      currentAction.current = action;
    }
   
   
    
    
    
    
      // console.log("action",action)
      // console.log("current",currentAction.current)
      // console.log(release)

      
    

    //hide object from scene when it reaches target
    // const distance = model.scene.position.distanceTo(targetPosition);
    // if(distance < 0.1){
    //  setArrowVisibility(false);
     
    // }
    // else{
    //   setArrowVisibility(true);
      
    // }
    // arrowRef.current.position.x += arrowDirectionX 
    //   arrowRef.current.position.y += arrowDirectionY
    //   arrowRef.current.position.z += arrowDirectionZ 
    }, [action, actions, forward, backward, left, right, jump, shift, shoot]);

    // useEffect(() => {
    //   timer = setTimeout(() => {
    //     console.log("time")
       
    //  }, 1000);
    //  return () => clearTimeout(timer);
    // }, [timer])


    useFrame((state, delta, mouse, clock) => {

      if(currentAction.current === "WalkForward" ||
      currentAction.current === "RunForward"
      ) {
        //calculate towards camera direction
        let angleYCameraDirection = Math.atan2(
          camera.position.x - model.scene.position.x,
          camera.position.z - model.scene.position.z
        )
        // console.log(actions)
        
        //diagonal movement angle offset
        let newDirectionOffset = directionOffset({
          forward,
          backward,
          left,
          right,
        });
        
        rotateQuarternion.setFromAxisAngle(
          rotateAngle,
          angleYCameraDirection + newDirectionOffset
        )
        model.scene.quaternion.rotateTowards(rotateQuarternion, 0.2);
        

        // calculate direction
        camera.getWorldDirection(walkDirection);
        walkDirection.y = 0;
        walkDirection.normalize();
        walkDirection.applyAxisAngle(rotateAngle, newDirectionOffset)

        // run/walk velocity
        let velocity = currentAction.current === "RunForward" ? 4 : 1.8;


        //intersections
        const intersections = raycast();
        
        
  
      const translation = api.current.translation();
      if (translation.y < -1) {
        // don't fall below ground

            translation.x = 0;
            translation.y = 10; 
            translation.z =  0;
        }
    


        walkDirection.y += (storedFall, -9.81 * delta, 0.10)
        storedFall = walkDirection.y
        
             
       
        
        if(intersections.length > 0){
          model.scene.position.copy(intersections[0].point)
          const point = intersections[0].point;
          let diff = model.scene.position.y - (point.y + 0.28);
          if(diff < 0.0){
            storedFall = 0;
            walkDirection.y += lerp(0, Math.abs(diff), 0.5);
          }
        }

        var originPoint = model.scene.position.clone();
      
        
       
        raycaster.set(originPoint, walkDirection)
        var intersects = raycaster.intersectObjects(scene.children);
        if(intersects.length > 0 && intersects[0].object.name === "Wall1" && intersects[0].object.position.distanceTo(model.scene.position) < 20){
          velocity = 0;
          console.log(intersects[0].object.name, model.scene.position.distanceTo(intersects[0].object.position))
        }
        else if(intersects.length > 0 && intersects[0].object.name === "Wall2" && intersects[0].object.position.distanceTo(model.scene.position) < 20 ){
          velocity = 0;
          console.log(intersects[0].object.name, model.scene.position.distanceTo(intersects[0].object.position))
        }
        else if(intersects.length > 0 && intersects[0].object.name === "Wall3" && intersects[0].object.position.distanceTo(model.scene.position) < 30){
          velocity = 0;
          console.log(intersects[0].object.name, model.scene.position.distanceTo(intersects[0].object.position))
        }
        else if(intersects.length > 0 && intersects[0].object.name === "Wall4" && intersects[0].object.position.distanceTo(model.scene.position) < 30 ){
          velocity = 0;
          console.log(intersects[0].object.name, model.scene.position.distanceTo(intersects[0].object.position))
        }
        else if(intersects.length > 0 && intersects[0].object.name == "obj4" && intersects[0].object.position.distanceTo(model.scene.position) < 20 ){
          velocity = 0;
          console.log(intersects[0].object.name, model.scene.position.distanceTo(intersects[0].object.position))
        }
        else{
          velocity = currentAction.current === "RunForward" ? 4 : 1.8;
        }
        
        
        // console.log(model.scene)
        // update model and camera
        const moveX = walkDirection.x * velocity * delta;
        const moveZ = walkDirection.z * velocity * delta;
        
        
        translation.x = model.scene.position.x += moveX;
        translation.y = model.scene.position.y += walkDirection.y
        translation.z = model.scene.position.z += moveZ;

       
       
        updateCameraTarget(moveX, moveZ);
        
        
      };
      
      const arrowTranslation = arrowApi.current.translation()
      
      let cameraDirection = new Vector3();
      camera.getWorldDirection(cameraDirection);

      let bulletDirection = cameraDirection.clone().multiplyScalar(20);
      // console.log(bulletDirection)

      const vector = new Vector3(crosshairPos)
      const arrowPosition = model.scene.position.clone()
      .add(vector.clone().multiplyScalar(2))

      //Shooting
      const arrowDirectionX = cameraDirection.x * arrowSpeed * 20 * delta;
      const arrowDirectionY = cameraDirection.y * arrowSpeed * 20 * delta;
      const arrowDirectionZ = cameraDirection.z * arrowSpeed * 20 * delta;

      

      // const arrowDirectionX = direction.x
      // const arrowDirectionY = direction.y 
      // const arrowDirectionZ = direction.z 

      // arrowModel.scene.position.x += arrowDirectionX
      // arrowModel.scene.position.y += arrowDirectionY
      // arrowModel.scene.position.z += arrowDirectionZ
      
      arrowRef.current.position.x += arrowDirectionX 
      arrowRef.current.position.y += arrowDirectionY
      arrowRef.current.position.z += arrowDirectionZ 

      // arrowRef.current.position.x += bulletDirection.x
      // arrowRef.current.position.y += bulletDirection.y
      // arrowRef.current.position.z += bulletDirection.z
     
      
      
      // const vector = new Vector3(0, 0, -0.8).unproject(camera)
      // console.log(crosshairPos)
      
      arrowTranslation.x = arrowRef.current.position.x 
      arrowTranslation.y = arrowRef.current.position.y
      arrowTranslation.z = arrowRef.current.position.z 
    
      // console.log(arrowTranslation)
      // console.log("ref",arrowRef.current1.position)
      
      
     
      
      if(shoot && !forward && !right && !left && !backward) {
        const now = Date.now();
        if (now >= timeToShoot) {
          timeToShoot = now + arrowCoolDown; 
          setArrows((arrows) => [
            ...arrows,
            {
              id: now,
              position: [arrowPosition.x, arrowPosition.y, arrowPosition.z],
              // forward: [bulletDirection.x, bulletDirection.y, bulletDirection.z]
            }
          ].slice(1,2));
          
        }
       
      }
      
    


      var dir = [arrowDirectionX, arrowDirectionY, arrowDirectionZ]
      // var dir = camera.getWorldDirection(arrowRef.current.position);
        var pos = [arrowRef.current.position.x, arrowRef.current.position.y, arrowRef.current.position.z]

       
        
        
        // console.log(dir)
        // console.log(pos)
        
        
        // var dir3 = camera.getWorldDirection(dir);
        // var pos3 = camera.getWorldPosition(pos)
        // raycaster.set(pos, dir)
        // var intersects = raycaster.intersectObjects(scene.children);

        
      // arrowRaycaster.set(arrowPosition, arrowRef.current.position);
      // console.log(arrowPosition, arrowRef.current.position)
      // console.log("pos",pos, "dir", dir2)
      var intersects = arrowRaycast();
      // var intersects = arrowRaycaster.intersectObjects(scene.children);
      // if(intersects.length > 0 ){
      //   console.log(intersects[0].object)
        
      // }
      // const BBS = new THREE.Box3();
      // let firstBB = new THREE.Box3().setFromObject(scene.children[0])
      // let secondBB = new THREE.Box3().setFromObject(scene.children[1])
      // let thirdBB = new THREE.Box3().setFromObject(scene.children[2])
      // let fourthBB = new THREE.Box3().setFromObject(scene.children[3])
      // let fifthBB = new THREE.Box3().setFromObject(scene.children[4])
      // let sixthBB = new THREE.Box3().setFromObject(scene.children[5])
      // let seventhBB = new THREE.Sphere().setFromPoints(scene.children[6])
      // let eightBB = new THREE.Box3().setFromObject(scene.children[7])
      // let ninthBB = new THREE.Box3().setFromObject(scene.children[8])
      // let tenthBB = new THREE.Box3().setFromObject(scene.children[9])
      // let elevenBB = new THREE.Box3().setFromObject(scene.children[10])
      // let twelveBB = new THREE.Box3().setFromObject(scene.children[11])
      // let thirteenBB = new THREE.Box3().setFromObject(scene.children[12])
      // let fourteenBB = new THREE.Box3().setFromObject(scene.children[13])

      // console.log(scene.children)

      // const BBs = [firstBB, secondBB, thirdBB, fourthBB, fifthBB, sixthBB, seventhBB, eightBB, ninthBB, tenthBB, elevenBB, twelveBB, thirteenBB, fourteenBB]
      // BBs.forEach(bb => {
        
      //     const otherBBs = BBs.filter(other => other !== BBs[6]);
      //     otherBBs.forEach(other => {
      //         // if(BBs[6].intersectsBox(other)){
      //         //   console.log(other)
      //         // }
            
      //       })
        
      //   // console.log(bb.children)
        

        
      // })

      // if(BBs[6].intersectsBox(BBs[2])){
      //   console.log("HIT",BBs[2])
      // }

        if(intersects.length > 0){
          arrowRef.current.position.copy(intersects[0].point)
          // console.log(intersects[0].object)
        }
          
        
      
      // else{
      //     setArrowVisibility(true);
      // }

    });

    

    return (
      
    <>
          
          <OrbitControls 
          ref={controlsRef} 
          target={model.scene.position} 
          // minPolarAngle={0} 
          // maxPolarAngle={Math.PI / 2}
          maxDistance={10001}
          // makeDefault={true}
          />
          {/* <PointerLockControls ref={controlsRef} camera={camera}/> */}
          {/* <AimTarget position={camera.position}/> */}
          <group>
            <RigidBody ref={api} colliders="ball" type="kinematicPosition" restitution={0.2}>
              <primitive 
              object={model.scene} 
              ref={ref} 
              name="Archer" 
              key={model.scene.uuid} 
              position={[-0.2, 3.05, 32]}/> 
            </RigidBody>
          
          </group>
          
            
          {arrows.map((arrow) => {
              return (
               <>

                  {/* <Arrow 
                    rotation={[0, 5 ,0]} 
                    position={arrow.position} 
                    // velocity={arrow.forward}
                    key={`${arrow.id}`}
                  /> */}
                  {/* <mesh visible={arrowVisibility ? true : false} >
                    <primitive 
                    // visible={!shoot}
                    object={arrowModel.scene} 
                    ref={arrowRef} 
                    position={arrow.position} 
                    key={`${arrow.id}`} 
                    scale={0.010}
                    rotation={arrow.rotation}
                    // transparent={true}
                    // visible={arrowVisibility}
                    
                    />
                  </mesh> */}
                    <mesh visible={!shoot}>
                    {/* <Trail
                      width={2} // Width of the line
                      length={10}
                      color={'white'} // Color of the line
                      decay={10}
                      attenuation={(x) => {return x * x}} // A function to define the width in each point along it.
                      target={arrowRef}
                      > */}
                        <RigidBody 
                                colliders="ball" 
                                ref={arrowApi}
                                type="kinematicPosition"
                                onCollisionEnter={({manifold}) => {
                                  console.log('Collision at world position ', manifold.solverContactPoint(0))
                                }}
                                
                                >
                          <Sphere args={[1, 64]} position={arrow.position} ref={arrowRef} key={`${arrow.id}`} name="sphere">
                            <meshBasicMaterial color="red"/>
                          </Sphere>
                       </RigidBody>
                    {/* </Trail> */}
                    </mesh>
                
               </> 
              );
          })}         
    </>

        
  )
}

useGLTF.preload('/archer.glb')

function usePrevious(value){
  const ref = useRef();
  useEffect(() => {
    ref.current = value
  },[value]);
  return ref.current;
}
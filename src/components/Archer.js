/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useAnimations, PerspectiveCamera, OrbitControls, CycleRaycast , useHelper, PointerLockControls} from '@react-three/drei'
import * as THREE from 'three';
import {Quaternion, Raycaster, Vector3, BoxHelper} from 'three';
import { useFrame, useThree, extend } from '@react-three/fiber';
import { useInput } from '../hooks/useInput';
import { Physics, RapierCollider, RigidBody, useRapier } from '@react-three/rapier';
import { Geometry } from "three-stdlib";
import { lerp } from 'three/src/math/MathUtils';
import { SwampModel } from './Swamp_location';
import { Arrow } from './Arrow';
import { Enemy } from './Enemy';
import Target from './Target';
import { AimTarget } from './AimTarget';


const directionOffset = ({forward, backward, left, right}) => {
  var directionOffset = 0; // w

  if(forward){
    if(left){
      directionOffset = Math.PI / 4 // w+a
    } else if (right){
      directionOffset = -Math.PI / 4 // w+d
    }
  } else if(backward){
    if(left) {
      directionOffset = Math.PI / 4 + Math.PI / 2 // s+a
    } else if (right){
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if(left){
    directionOffset = Math.PI / 2; // a
  } else if(right){
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

const useForwardRaycast = (obj) => {
  const raycaster = useMemo(() => new Raycaster(), [])
  const pos = useMemo(() => new Vector3(), [])
  const dir = useMemo(() => new Vector3(), [])
  dir.set(0, -1 , 0)
  const scene = useThree((state) => state.scene)
  
  return () => {
    if (!obj.current) return []
    // raycaster.set(obj.current.getWorldPosition(pos), obj.current.getWorldDirection(dir))
    raycaster.set(obj.current.getWorldPosition(pos), dir)
    return raycaster.intersectObjects(scene.children)
  }
}

const useArrowRaycast = (obj) => {
  const raycaster = useMemo(() => new Raycaster(), [])
  const pos = useMemo(() => new Vector3(), [])
  const dir = useMemo(() => new Vector3(), [])
  dir.set(0, 0, -1)
  const scene = useThree((state) => state.scene)
  
  return () => {
    if (!obj.current) return []
    // raycaster.set(obj.current.getWorldPosition(pos), obj.current.getWorldDirection(dir))
    raycaster.set(obj.current.getWorldPosition(pos), dir)
    return raycaster.intersectObjects(scene.children)
  }
}

export function Model({action, position}) {

  const group = useRef()
  const currentAction = useRef("");
  const controlsRef = useRef(OrbitControls);
  const {forward, backward, left, right, jump, shift, shoot} = useInput();
  const model = useGLTF('/ErikaArcherWithAimingAnimationsNew.glb');
  const arrowModel = useGLTF("/arrow.glb")
  const { actions } = useAnimations(model.animations, model.scene)
  const previousAction = usePrevious(action);
  const camera = useThree(state => state.camera);
  const {scene} = useThree();
  const [arrows, setArrows] = useState([]);




  const api = useRef();
  const ref = useRef();
  const swampRef = useRef();
  const arrowRef = useRef();
  const raycast = useForwardRaycast(ref);
  const swampRaycast = useForwardRaycast(swampRef);
  let enemyPosition = new THREE.Vector3();
  let cameraDirection = new Vector3();
      
 

  const arrowSpeed = 80;
  const arrowCoolDown = 300;
  let timeToShoot = 0;

  const updateCameraTarget = (moveX, moveZ) => {
    // move camera
    camera.position.x += moveX;
    camera.position.z += moveZ;
    // camera.position.y += moveY;
    

    // update camera target
    cameraTarget.x = model.scene.position.x;
    cameraTarget.y = model.scene.position.y + 2;
    cameraTarget.z = model.scene.position.z;
    if(controlsRef.current) controlsRef.current.target = cameraTarget;
  };


  let walkDirection = new THREE.Vector3();
  let rotateAngle = new THREE.Vector3(0, 1, 0);
  let rotateQuarternion = new THREE.Quaternion();
  let cameraTarget = new THREE.Vector3();
  let storedFall = 0;
  

  
  useEffect(() => {
  
    if(previousAction){
      // actions[previousAction].stop()
    }
    let action = "";
    const now = Date.now();
    
    if(forward|| backward || left || right){
      action = "WalkForward";
      if(shift){
        action = "RunForward"
        if(jump){
          action = "RunningJump"
        }
      }
    } else if(jump){
      action = "Jump";

    } else if(shoot){
      action = "StandingDrawArrow";
      // actions[action]?.setLoop(THREE.LoopOnce)

    } else{
      action = "Idle";

    } 

    if(currentAction.current != action){
      const nextActionToPlay = actions[action];
      const current = actions[currentAction.current];
      current?.fadeOut(0.2);
      nextActionToPlay?.reset().fadeIn().play();
      currentAction.current = action;
    }

    }, [action, actions, forward, backward, left, right, jump, shift, shoot]);


    useFrame((state, delta, mouse) => {
      if(currentAction.current === "WalkForward" ||
      currentAction.current === "RunForward"
      ) {
        //calculate towards camera direction
        let angleYCameraDirection = Math.atan2(
          camera.position.x - model.scene.position.x,
          camera.position.z - model.scene.position.z
        )
        // console.log(actions)

        //diagonal movement angle offset
        let newDirectionOffset = directionOffset({
          forward,
          backward,
          left,
          right,
        });

        rotateQuarternion.setFromAxisAngle(
          rotateAngle,
          angleYCameraDirection + newDirectionOffset
        )
        model.scene.quaternion.rotateTowards(rotateQuarternion, 0.2);
        

        // calculate direction
        camera.getWorldDirection(walkDirection);
        walkDirection.y = 0;
        walkDirection.normalize();
        walkDirection.applyAxisAngle(rotateAngle, newDirectionOffset)

        // run/walk velocity
        let velocity = currentAction.current == "RunForward" ? 4 : 1.8;


        //intersections
        const intersections = raycast();
        const swampIntersections = swampRaycast();
        
        
        const walkable = scene.children.filter(
          (o) => o.children[0]?.uuid !== ref?.current?.uuid
        );
  
      const translation = api.current.translation();
      if (translation.y < -1) {
        // don't fall below ground

            translation.x = 0;
            translation.y = 10; 
            translation.z =  0;
        }
    
      // } else {
        walkDirection.y += (storedFall, -9.81 * delta, 0.10)
        storedFall = walkDirection.y
        
        if(intersections.length > 0){
          model.scene.position.copy(intersections[0].point)
          const point = intersections[0].point;
          let diff = model.scene.position.y - (point.y + 0.28);
          if(diff < 0.0){
            storedFall = 0;
            walkDirection.y += lerp(0, Math.abs(diff), 0.5);
            // console.log(point);
          }
        }

        // update model and camera
        const moveX = walkDirection.x * velocity * delta;
        const moveZ = walkDirection.z * velocity * delta;
        
        
        translation.x = model.scene.position.x += moveX;
        translation.y = model.scene.position.y += walkDirection.y
        translation.z = model.scene.position.z += moveZ;

        updateCameraTarget(moveX, moveZ);
        

       
        
      };

      

      camera.getWorldDirection(cameraDirection);

      //Shooting
      const arrowDirectionX = cameraDirection.x * arrowSpeed * delta;
      const arrowDirectionY = cameraDirection.y * arrowSpeed * delta;
      const arrowDirectionZ = cameraDirection.z * arrowSpeed * delta;

      arrowModel.scene.position.x += arrowDirectionX
      arrowModel.scene.position.y += arrowDirectionY
      arrowModel.scene.position.z += arrowDirectionZ

      const arrowPosition = model.scene.position.clone()
      .add(cameraDirection.clone().multiplyScalar(2))

      if(currentAction.current === "StandingDrawArrow") {
        
        const now = Date.now();
        if (now >= timeToShoot) {
          timeToShoot = now + arrowCoolDown;
          setArrows((arrows) => [
            ...arrows,
            {
              id: now,
              position: [arrowPosition.x, arrowPosition.y+1.5, arrowPosition.z],
              rotation: [cameraDirection.x+5, cameraDirection.y+5, cameraDirection.z+5]
              // forward: [arrowModel.scene.position.x += arrowDirectionX, arrowModel.scene.position.y += arrowDirectionY, arrowModel.scene.position.z += arrowDirectionZ]
            }
          ]);
        }
      }
     
      
    });

    return (
    <>
          
          <OrbitControls 
          ref={controlsRef} 
          target={model.scene.position} 
          minPolarAngle={0} 
          maxPolarAngle={Math.PI / 2}
          maxDistance={100}
          />
          {/* <AimTarget position={camera.position}/> */}
          <group>
            <RigidBody ref={api} colliders="ball" type="kinematicPosition" >
              <primitive 
              object={model.scene} 
              ref={ref} name="Archer" 
              key={model.scene.uuid} 
              position={[-0.2, 3.05, 32]}/> 
            </RigidBody>
          
          </group>
            
          {arrows.map((arrow) => {
              return (
                <RigidBody type="kinematicPosition" colliders="trimesh" >
                  {/* <Arrow 
                    rotation={[0, 5 ,0]} 
                    position={arrow.position} 
                    // velocity={arrow.forward}
                    key={`${arrow.id}`}
                  /> */}
                  <primitive 
                  visible={!shoot}
                  object={arrowModel.scene} 
                  ref={arrowRef} 
                  position={arrow.position} 
                  key={`${arrow.id}`} 
                  scale={0.010}
                  rotation={arrow.rotation}
                  />
                </RigidBody>
              );
          })}

          {/* <Enemy position={enemyPosition}/> */}
          <Target/>

    </>


  )
}

useGLTF.preload('/archer.glb')

function usePrevious(value){
  const ref = useRef();
  useEffect(() => {
    ref.current = value
  },[value]);
  return ref.current;
}